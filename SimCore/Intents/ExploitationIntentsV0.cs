using SimCore.Tweaks;

namespace SimCore.Intents;

/// <summary>
/// GATE.S3_6.EXPLOITATION_PACKAGES.002
/// Single-mutation pipeline intents for TradeCharterV0 and ResourceTapV0.
/// All ledger mutations happen in Apply(state). No wall-clock, no shared RNG.
/// </summary>
public sealed class TradeCharterIntentV0 : IIntent
{
    public string Kind => "TRADE_CHARTER_V0";

    public readonly string SourceMarketId;
    public readonly string DestMarketId;
    public readonly string BuyGoodId;
    public readonly string SellGoodId;
    public readonly string ProgramId;

    public TradeCharterIntentV0(
        string sourceMarketId, string destMarketId,
        string buyGoodId, string sellGoodId, string programId)
    {
        SourceMarketId = sourceMarketId ?? "";
        DestMarketId = destMarketId ?? "";
        BuyGoodId = buyGoodId ?? "";
        SellGoodId = sellGoodId ?? "";
        ProgramId = programId ?? "";
    }

    public void Apply(SimState state)
    {
        if (state is null) return;

        var batch = ExploitationTweaksV0.TradeCharterBatchSize;

        // BUY LEG
        if (!string.IsNullOrEmpty(BuyGoodId) && !string.IsNullOrEmpty(SourceMarketId))
        {
            if (!state.Markets.TryGetValue(SourceMarketId, out var src) || src is null)
            {
                state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} NoExportRoute src={SourceMarketId}");
            }
            else
            {
                var available = src.Inventory.TryGetValue(BuyGoodId, out var inv) ? inv : 0;
                var buyQty = Math.Min(batch, available);
                if (buyQty > 0)
                {
                    var cost = checked(ExploitationTweaksV0.TradeCharterBuyPricePerUnit * buyQty);
                    if (state.PlayerCredits < cost)
                    {
                        state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} BudgetExhausted need={cost} have={state.PlayerCredits}");
                    }
                    else
                    {
                        state.PlayerCredits = checked(state.PlayerCredits - cost);
                        src.Inventory[BuyGoodId] = available - buyQty;
                        state.PlayerCargo.TryGetValue(BuyGoodId, out var ch);
                        state.PlayerCargo[BuyGoodId] = checked(ch + buyQty);
                        state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} InventoryLoaded good={BuyGoodId} qty={buyQty} cost={cost}");
                    }
                }
            }
        }

        // SELL LEG
        if (!string.IsNullOrEmpty(SellGoodId) && !string.IsNullOrEmpty(DestMarketId))
        {
            if (!state.Markets.TryGetValue(DestMarketId, out var dst) || dst is null)
            {
                state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} NoExportRoute dst={DestMarketId}");
                return;
            }
            var have = state.PlayerCargo.TryGetValue(SellGoodId, out var ch2) ? ch2 : 0;
            var sellQty = Math.Min(batch, have);
            if (sellQty > 0)
            {
                var rev = checked(ExploitationTweaksV0.TradeCharterSellPricePerUnit * sellQty);
                state.PlayerCredits = checked(state.PlayerCredits + rev);
                state.PlayerCargo[SellGoodId] = have - sellQty;
                dst.Inventory.TryGetValue(SellGoodId, out var di);
                dst.Inventory[SellGoodId] = checked(di + sellQty);
                state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} TradePnL good={SellGoodId} qty={sellQty} revenue={rev}");
                state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} InventoryUnloaded good={SellGoodId} qty={sellQty}");
            }
        }
    }
}

public sealed class ResourceTapIntentV0 : IIntent
{
    public string Kind => "RESOURCE_TAP_V0";

    public readonly string SourceMarketId;
    public readonly string ExtractGoodId;
    public readonly string ProgramId;

    public ResourceTapIntentV0(string sourceMarketId, string extractGoodId, string programId)
    {
        SourceMarketId = sourceMarketId ?? "";
        ExtractGoodId = extractGoodId ?? "";
        ProgramId = programId ?? "";
    }

    public void Apply(SimState state)
    {
        if (state is null) return;

        if (!state.Markets.TryGetValue(SourceMarketId, out var market) || market is null)
        {
            state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} NoExportRoute src={SourceMarketId}");
            return;
        }

        var extract = ExploitationTweaksV0.ResourceTapExtractBatch;
        var export = ExploitationTweaksV0.ResourceTapExportBatch;

        market.Inventory.TryGetValue(ExtractGoodId, out var before);
        market.Inventory[ExtractGoodId] = checked(before + extract);
        state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} Produced good={ExtractGoodId} qty={extract}");

        var afterProduce = market.Inventory[ExtractGoodId];
        var exportQty = Math.Min(export, afterProduce);
        if (exportQty > 0)
        {
            market.Inventory[ExtractGoodId] = afterProduce - exportQty;
            state.PlayerCargo.TryGetValue(ExtractGoodId, out var ch);
            state.PlayerCargo[ExtractGoodId] = checked(ch + exportQty);
            state.AppendExploitationEvent($"tick={state.Tick} prog={ProgramId} InventoryUnloaded good={ExtractGoodId} qty={exportQty}");
        }
    }
}
