# 55_GATES

## A. Slice 0 discipline gates (always-on)

| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.S0.SEM.001 | DONE | Slice 0 is ALWAYS_ON discipline: even if current tooling/boundary gates are DONE, Slice 0 remains IN_PROGRESS as new invariants and boundaries are added; this doc must state that status semantics unambiguously to avoid historical contradiction | docs/55_GATES.md (this section) |

## B. Slice 1 and 1.5 gates (locked execution gates)

### B1. Workflow and tooling gates
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.TOOL.001 | DONE | Deterministic status packet generation exists (diff-driven, capped) | docs/generated/02_STATUS_PACKET.txt |
| GATE.CONN.001 | DONE | Connectivity scan outputs deterministic manifests | docs/generated/connectivity_manifest.json; docs/generated/connectivity_graph.json |
| GATE.CONN.002 | DONE | Connectivity violations empty for Slice scope | docs/generated/connectivity_violations.json |
| GATE.TEST.001 | DONE | Headless determinism harness exists | SimCore.Tests/GoldenReplayTests.cs |
| GATE.TEST.002 | DONE | Golden world hash regression exists and is stable | docs/generated/snapshots/golden_replay_hashes.txt |
| GATE.EVID.001 | DONE | Context packet reports latest scan + test summary + hash snapshot presence (or explicit “not found” reasons) | docs/generated/01_CONTEXT_PACKET.md ([SYSTEM HEALTH] shows Connectivity OK + Tests OK + Hash Snapshot present) |
| GATE.MAP.001 | DONE | Repo evidence export exists (tests index + grep + map) | docs/generated/evidence/simcore_tests_index.txt + docs/generated/evidence/gate_evidence_grep.txt + docs/generated/evidence/gate_evidence_map.json |
| GATE.FILE.001 | DONE | Runtime File Contract enforced (runtime IO restricted to res:// and user://; SimCore has no System.IO IO) | SimCore.Tests/Invariants/RuntimeFileContractTests.cs |

### B2. Slice 1 critical gates
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.TIME.001 | DONE | 60x time contract enforced: 1s real = 1 min sim, no acceleration | SimCore.Tests/TimeContractTests.cs |
| GATE.INTENT.001 | DONE | Deterministic intent pipeline exists | SimCore.Tests/Intents/IntentSystemTests.cs + scripts/bridge/SimBridge.cs (EnqueueIntent) |
| GATE.WORLD.001 | DONE | 2 stations, 1 lane, 2 goods micro-world config | SimCore.Tests/World/World001_MicroWorldLoadTests.cs + SimCore.Tests/Intents/IntentSystemTests.cs (KernelWithWorld001) |
| GATE.STA.001 | DONE | Station inventory ledger and invariants | SimCore.Tests/Systems/InventoryLedgerTests.cs + SimCore.Tests/Invariants/InventoryConservationTests.cs; SimCore.Tests/Invariants/BasicStateInvariantsTests.cs |
| GATE.LANE.001 | DONE | Lane flow with deterministic delay arrivals | SimCore.Tests/Systems/LaneFlowSystemTests.cs |
| GATE.MKT.001 | DONE | Inventory-based pricing with spread | SimCore.Tests/MarketTests.cs + SimCore.Tests/Systems/MarketPublishCadenceTests.cs |
| GATE.MKT.002 | DONE | Price publish cadence every 12 game hours | SimCore.Tests/Systems/MarketPublishCadenceTests.cs |
| GATE.INTEL.001 | DONE | Local truth, remote banded intel + age | SimCore.Tests/Systems/IntelContractTests.cs |
| GATE.UI.001 | DONE | Minimal panel shows inventory, price, intel age | scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs |
| GATE.UI.002 | DONE | Buy/sell generates intent, no direct mutation | scripts/ui/StationMenu.cs (SubmitBuyIntent/SubmitSellIntent) + scripts/bridge/SimBridge.cs (EnqueueIntent + BuyIntent/SellIntent) + SimCore.Tests/Intents/IntentSystemTests.cs |
| GATE.DET.001 | DONE | 10,000 tick run stable world hash | SimCore.Tests/Determinism/LongRunWorldHashTests.cs (LongRunWorldHash) + docs/generated/05_TEST_SUMMARY.txt |
| GATE.SAVE.001 | DONE | Save/load round trip preserves hash | SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs (SaveLoadWorldHash) + docs/generated/05_TEST_SUMMARY.txt |
| GATE.INV.001 | DONE | Invariants suite passes | SimCore.Tests/Invariants/InventoryConservationTests.cs (InventoryConservation); SimCore.Tests/Invariants/BasicStateInvariantsTests.cs (BasicStateInvariants) + docs/generated/05_TEST_SUMMARY.txt |

### B3. Slice 1.5 sustainment gates
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.TECH.001 | DONE | One tech requires 2 goods per tick to remain enabled | SimCore.Tests/Sustainment/TechUpkeepConsumesGoodsTests.cs |
| GATE.TECH.002 | DONE | Buffers sized in days of game time | SimCore.Tests/Sustainment/BufferSizingDaysTests.cs |
| GATE.TECH.003 | DONE | Deterministic degradation under undersupply | SimCore.Tests/Sustainment/DeterministicDegradationTests.cs |
| GATE.UI.101 | DONE | UI shows sustainment margin and time-to-failure | scripts/ui/StationMenu.cs; scripts/bridge/SimBridge.cs; SimCore/Systems/SustainmentReport.cs |
| GATE.DET.101 | DONE | Sustainment determinism regression passes | SimCore.Tests/Sustainment/SustainmentDeterminismRegressionTests.cs |
| GATE.INV.101 | DONE | Buffer math invariants pass | SimCore.Tests/Sustainment/BufferMathInvariantsTests.cs |

### B4. Slice 2 programs gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.PROG.001 | DONE | Program schema v1 exists (TradeProgram only) and is versioned | SimCore/Schemas/ProgramSchema.json + SimCore.Tests/Programs/ProgramContractTests.cs (PROG_001) |
| GATE.FLEET.001 | DONE | Fleet binding v1 exists (single trader fleet) and is deterministic | SimCore/World/WorldLoader.cs + SimCore.Tests/Programs/FleetBindingContractTests.cs + docs/generated/05_TEST_SUMMARY.txt |
| GATE.DOCTRINE.001 | DONE | DefaultDoctrine exists (max 2 toggles) and is deterministic | SimCore/Programs/DefaultDoctrine.cs + SimCore.Tests/Programs/DefaultDoctrineContractTests.cs |
| GATE.QUOTE.001 | DONE | Liaison Quote is deterministic: request + snapshot => quote (cost/time/risks/constraints) | SimCore/Programs/ProgramQuote.cs + SimCore/Programs/ProgramQuoteSnapshot.cs + SimCore.Tests/Programs/ProgramQuoteContractTests.cs + SimCore.Tests/TestData/Snapshots/program_quote_001.json + docs/generated/05_TEST_SUMMARY.txt |
| GATE.EXPLAIN.001 | DONE | Explain events are schema-bound (no free-text) for quote and outcomes | SimCore.Tests/Programs/ProgramContractTests.cs (EXPLAIN_001) |
| GATE.PROG.EXEC.001 | DONE | Program execution emits intents only, no direct ledger mutation | SimCore.Tests/Programs/ProgramContractTests.cs (PROG_EXEC_001) + SimCore/Programs/ProgramSystem.cs |
| GATE.PROG.EXEC.002 | DONE | TradeProgram drives buy/sell intents against Slice 1 micro-world and affects outcomes only via SimCore tick | SimCore.Tests/Programs/ProgramExecutionIntegrationTests.cs + docs/generated/05_TEST_SUMMARY.txt |
| GATE.BRIDGE.PROG.001 | DONE | GameShell -> SimCore bridge supports program lifecycle (create/start/pause) without direct state mutation | scripts/bridge/SimBridge.cs + SimCore.Tests/Programs/ProgramLifecycleContractTests.cs + SimCore.Tests/Programs/ProgramStatusCommandContractTests.cs |
| GATE.UI.PROG.001 | DONE | Minimal Programs UI: create, view quote, start/pause, last-tick outcomes | scripts/ui/ProgramsMenu.cs + scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs + scenes/playable_prototype.tscn |
| GATE.VIEW.001 | DONE | Playable prototype camera is a ship-follow orbit camera (zoom + rotate) and player has a ship placeholder mesh | scripts/view/player_follow_camera.gd + scenes/player.tscn + scenes/playable_prototype.tscn |
| GATE.DET.PROG.001 | DONE | Determinism regression includes program lifecycle (create/start/pause) with stable hash | SimCore.Tests/Determinism/ProgramDeterminismTests.cs + SimCore.Tests/SaveLoad/ProgramSaveLoadContractTests.cs |
| GATE.UI.PROG.001 | DONE | Minimal Programs UI: create, view quote, start/pause, last-tick outcomes | scripts/ui/ProgramsMenu.cs + scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs + scenes/playable_prototype.tscn |
| GATE.VIEW.001 | DONE | Playable prototype camera is a ship-follow orbit camera (zoom + rotate) and player has a ship placeholder mesh | scripts/view/player_follow_camera.gd + scenes/player.tscn + scenes/playable_prototype.tscn |

### B4.5 Slice 2.5 seed plumbing gates (v0)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.S2_5.SEEDS.001 | DONE | Axis: seed_input. Plumb Seed into galaxy generation entrypoint and persist on SimState. Acceptance: Headless Godot compile smoke clean (no Parse Error/Compilation failed) % Seed stored on SimState.seed and used by galaxy_generator.generate_for_state % Anti-pattern scan OK (no randomize/wall-clock/global randf/randi in core scan) % Headless determinism smoke exits 0 and prints digest_1==digest_2 for same Seed+regions. Closure proof: seed_smoke_stdout shows digest match + DETERMINISM_OK; Validate-GodotScript EXIT_CODE=0 for sim_state.gd and galaxy_generator.gd. | scripts/core/sim/galaxy_generator.gd + scripts/core/state/sim_state.gd + scripts/core/galaxy_graph.gd |
| GATE.S2_5.SEEDS.002 | DONE | Axis: rng_streams; Intent: Define a stable RNG stream contract keyed by Seed + stream name so adding systems does not perturb existing randomness; Delta: RNG stream partitioning exists conceptually but is not gate-specified as the required mechanism for Seed-based worldgen; Acceptance: Godot headless parse passes for scripts/core/sim/rng_streams.gd / Each stream is derived from Seed + stable stream key and does not depend on call order from other systems / Adding a new stream does not change outputs of existing stream keys for the same Seed / scripts/core/sim/galaxy_generator.gd consumes only named streams for all randomness; Status rules: TODO->IN_PROGRESS once stream-derivation API is explicit and used by worldgen; IN_PROGRESS->DONE when acceptance checks pass; BLOCKED if any consumer uses non-stream RNG in the worldgen path; Closure proof: Validate-GodotScript PASS (exit code 0) for scripts/core/sim/rng_streams.gd and scripts/core/sim/galaxy_generator.gd; legacy keys use fixed offsets from Seed; new keys seed from (Seed, stable_stream_name) hash; galaxy_generator uses STREAM_GALAXY_GEN;
| GATE.S2_5.SEEDS.003 | DONE | Axis: gameshell_regression; Intent: Add a minimal GameShell seed determinism regression test that exercises galaxy generation twice with the same Seed; Delta: No existing GameShell gate asserts identical generation for identical Seed or protects against accidental nondeterminism in .gd worldgen scripts; Acceptance: Godot headless run passes for scripts/tests/test_galaxy_core.gd / Test generates twice with the same Seed and asserts identical ordered nodes%edges representation / Test generates with two different Seeds and asserts at least one deterministic structural difference / Test output is stable for diffing (explicit ordering, no timestamps); Status rules: TODO->IN_PROGRESS once the test is written and fails on current nondeterministic behavior (if any); IN_PROGRESS->DONE when test passes and is stable across reruns; BLOCKED if test cannot run headlessly in repo workflow; Closure proof: scripts/tests/test_galaxy_core.gd assertion output proves same-Seed equality and cross-Seed difference; Evidence universe: Anchor=scripts/tests/test_galaxy_core.gd, Extra=scripts/core/sim/galaxy_generator.gd,scripts/core/sim/rng_streams.gd | scripts/tests/test_galaxy_core.gd + scripts/core/sim/galaxy_generator.gd + scripts/core/sim/rng_streams.gd |
| GATE.S2_5.SEEDS.004 | DONE | Axis: save_seed_identity; Intent: Persist Seed as part of SimCore world identity and ensure Serialization round-trip preserves it exactly; Delta: GATE.SAVE.001 proves hash equivalence but does not explicitly require that Seed and worldgen parameters are saved%loaded as identity inputs; Acceptance: dotnet test passes including SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs / WorldLoader stores Seed in a stable world identity field (or equivalent) used by downstream worldgen / Serialization payload includes Seed and Load restores it exactly / Failure output includes the Seed value used so repro is trivial; Status rules: TODO->IN_PROGRESS once Seed is added to the SimCore identity structure and wired into serialization; IN_PROGRESS->DONE when the save/load test asserts Seed identity and passes; BLOCKED if adding Seed breaks existing save/load hashes without explicit migration note; Closure proof: SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs asserts Seed preserved across save/load and reports Seed on failure; Evidence universe: Anchor=SimCore/World/WorldLoader.cs, Extra=SimCore/Systems/SerializationSystem.cs,SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs | SimCore/World/WorldLoader.cs + SimCore/Systems/SerializationSystem.cs + SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs | Proof phrase: "dotnet test SimCore.Tests/SimCore.Tests.csproj -c Release passes; SaveLoadWorldHashTests prints Seed(saved)=123 and Seed(resaved)=123 with matching hashes."
| GATE.S2_5.SEEDS.005 | DONE | Axis: determinism_seed_repro; Intent: Make determinism harnesses that create worlds surface the Seed used (input or recorded) so long-run drift is reproducible; Delta: Existing determinism gates did not surface Seed as an explicit repro input%output for the long-run world-creating harness; Acceptance: dotnet test SimCore.Tests/SimCore.Tests.csproj -c Release passes including SimCore.Tests/Determinism/LongRunWorldHashTests.cs / Long-run harness accepts Seed via STE_LONGRUN_SEED (default stable) and includes Seed in assertion failure messages / Re-running with the same Seed yields identical world hash checkpoints at ticks 0, 1000, 5000, 10000 (A vs B) / Harness introduces no new nondeterminism sources; Status rules: TODO->IN_PROGRESS once Seed is part of the harness configuration or failure reporting; IN_PROGRESS->DONE when acceptance checks pass; BLOCKED if harness cannot be made seed-reproducible without broader refactor; Closure proof: LongRunWorldHashTests includes Seed in assertion messages and prints checkpoint hashes (0%1000%5000%10000) enabling repro via STE_LONGRUN_SEED; Evidence universe: Anchor=SimCore.Tests/Determinism/LongRunWorldHashTests.cs, Extra=SimCore/World/WorldLoader.cs | SimCore.Tests/Determinism/LongRunWorldHashTests.cs + SimCore/World/WorldLoader.cs |
| GATE.S2_5.SEEDS.006 | DONE | Axis: spec_docs; Intent: Define canonical Seed identity vocabulary and determinism%save/load regression reporting requirements in kernel docs, aligned to SaveLoadWorldHashTests; Acceptance: docs/21_90_TERMS_UNITS_IDS.md defines Seed (int32) and Seed%WorldId token; docs/20_TESTING_AND_DETERMINISM.md requires determinism%save/load regressions include Seed for repro and save envelope uses `Seed` + `State`; Proof: dotnet test SimCore.Tests/SimCore.Tests.csproj -c Release passes incl SaveLoadWorldHashTests; Closure proof: Docs diff in docs/21_90_TERMS_UNITS_IDS.md + docs/20_TESTING_AND_DETERMINISM.md and passing tests confirm contract alignment | docs/21_90_TERMS_UNITS_IDS.md + docs/20_TESTING_AND_DETERMINISM.md + SimCore.Tests/SaveLoad/SaveLoadWorldHashTests.cs |


### B5. Slice 3 logistics gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.ROUTE.001 | DONE | Deterministic route planner exists: from node to node => ordered edges/nodes + total travel ticks (stable tie-breaks by EdgeId/NodeId) | SimCore/Systems/RoutePlanner.cs + SimCore.Tests/Systems/RoutePlannerTests.cs |
| GATE.FLEET.ROUTE.001 | DONE | Fleet travel can follow a planned multi-edge route (lane sequence) without nondeterminism | SimCore/Systems/MovementSystem.cs + SimCore/Entities/Fleet.cs + SimCore.Tests/Systems/FleetRouteTravelTests.cs |
| GATE.LOGI.JOB.001 | DONE | LogisticsJob can represent multi-hop shipments (source, sink, good, qty, route) and is deterministic | SimCore/Entities/LogisticsJob.cs + SimCore.Tests/Systems/LogisticsJobContractTests.cs |

### B6. Slice 3 logistics execution gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.LOGI.CARGO.001 | DONE | Fleet has deterministic cargo storage (dict keyed by GoodId) that round-trips through save/load; cargo changes only via intent resolution (no direct mutation in LogisticsSystem) | SimCore/Entities/Fleet.cs + SimCore/Systems/SerializationSystem.cs + SimCore.Tests/SaveLoad/FleetCargoSaveLoadContractTests.cs |
| GATE.LOGI.XFER.001 | DONE | Deterministic load/unload intents+commands exist: market inventory <-> fleet cargo; operations clamp to available inventory/cargo; never produce negative counts | SimCore/Intents/LoadCargoIntent.cs + SimCore/Intents/UnloadCargoIntent.cs + SimCore/Commands/LoadCargoCommand.cs + SimCore/Commands/UnloadCargoCommand.cs + SimCore.Tests/Systems/LogisticsTransferContractTests.cs |
| GATE.LOGI.EXEC.001 | DONE | LogisticsJob executes end-to-end across ticks under kernel order: follow planned route legs, travel to source, issue load once (latched), travel to target, issue unload once (latched), clear job; no double-issue while idle at node | SimCore/Systems/LogisticsSystem.cs + SimCore/Entities/LogisticsJob.cs + SimCore.Tests/Systems/LogisticsJobExecutionTests.cs |
| GATE.LOGI.DET.001 | DONE | Multi-fleet logistics determinism regression: 2 fleets executing jobs in same world yields stable final world hash (tie-break by Fleet.Id for lane capacity, job advancement, and intent emission) | SimCore.Tests/Determinism/LogisticsMultiFleetDeterminismTests.cs |
| GATE.LOGI.MUT.001 | DONE | Single mutation pipeline contract: Commands may enqueue intents only; ONLY kernel intent resolution may mutate cargo and market inventory; LogisticsSystem and command handlers must not directly mutate cargo/inventory (guard with tests) | SimCore.Tests/Sustainment/LogisticsMutationPipelineContractTests.cs |
| GATE.LOGI.EVENT.001 | DONE | Logistics emits schema-bound, deterministic events for phase transitions and actions (Assign, ArriveSource, LoadIssued, Loaded, ArriveSink, UnloadIssued, Unloaded, Complete, Canceled); event ordering is stable under ties | SimCore/Events/LogisticsEvents.cs + SimCore.Tests/Systems/LogisticsEventStreamContractTests.cs |
| GATE.LOGI.SAVE.001 | DONE | Save/load preserves active logistics execution: mid-job phase, latched transfer state, route progress index, remaining amount, and any reservations restore deterministically; replay after load matches uninterrupted final hash | SimCore.Tests/SaveLoad/SaveLoadLogisticsMidJobTests.cs |
| GATE.LOGI.ORDER.001 | DONE | Logistics ordering deterministic under contention (multiple fleets, same tick) | SimCore.Tests/Determinism/LogisticsOrderingDeterminismTests.cs |

### B7. Slice 3 logistics fulfillment correctness gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.LOGI.FULFILL.001 | DONE | Partial pickup supported: if supplier inventory < job.Amount, pickup clamps deterministically and job tracks remaining amount (no negatives, no “complete without goods”) | SimCore/Systems/LogisticsSystem.cs + SimCore/Entities/LogisticsJob.cs + SimCore.Tests/Systems/LogisticsPartialFulfillmentTests.cs |
| GATE.LOGI.RETRY.001 | DONE | If pickup yields 0 for N consecutive ticks at source (supplier empty), job deterministically retries up to N observations then cancels (defined behavior; tested) | SimCore/Systems/LogisticsSystem.cs + SimCore/Entities/LogisticsJob.cs + SimCore.Tests/Systems/LogisticsRetryOrCancelContractTests.cs |
| GATE.LOGI.CANCEL.001 | DONE | Job cancel is deterministic: releases any latched transfer state, clears route state safely, and leaves fleet in a consistent Idle state | SimCore/Systems/LogisticsSystem.cs + SimCore.Tests/Systems/LogisticsCancelContractTests.cs |
| GATE.LOGI.RESERVE.001 | DONE | Planner can optionally reserve supplier inventory at assignment time to prevent over-allocation; reservation release is deterministic on cancel/complete | SimCore/Entities/LogisticsReservation.cs + SimCore/SimState.cs + SimCore/Commands/LoadCargoCommand.cs + SimCore/Systems/LogisticsSystem.cs + SimCore.Tests/Systems/LogisticsReservationContractTests.cs |

### B8. Slice 3 fleet control surface gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.UI.FLEET.001 | DONE | Read-only Fleet panel lists fleets sorted by Fleet.Id and shows: current node, state, job phase, job good/remaining, cargo summary, and route progress (edge index/total) | scripts/ui/FleetMenu.cs + scripts/bridge/SimBridge.cs |
| GATE.UI.FLEET.002 | DONE | Player can cancel a fleet job via command (no direct mutation) and sees deterministic state transition (job cleared, route cleared, task updated) | scripts/ui/FleetMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Commands/FleetJobCancelCommand.cs + SimCore.Tests/Systems/FleetJobCancelContractTests.cs |
| GATE.UI.FLEET.003 | DONE | Manual destination override exists via command and persists through save/load; override semantics are defined (overrides job routing until cleared) and deterministic | scripts/ui/FleetMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Commands/FleetSetDestinationCommand.cs + SimCore.Tests/SaveLoad/FleetManualOverrideSaveLoadContractTests.cs |
| GATE.UI.FLEET.AUTH.001 | DONE | Authority and precedence contract is explicit and enforced: each fleet reports ActiveController (None, Program, LogisticsJob, ManualOverride) with deterministic precedence ManualOverride > LogisticsJob > Program > None; issuing ManualOverride deterministically cancels any active LogisticsJob (reason token stable) and clears latched transfer state; clearing ManualOverride does not resume canceled jobs | SimCore/Entities/Fleet.cs + SimCore/Commands/FleetSetDestinationCommand.cs + SimCore.Tests/Systems/FleetAuthorityPrecedenceContractTests.cs |
| GATE.UI.FLEET.EVENT.001 | DONE | Fleet panel shows last N schema-bound events relevant to that fleet (logistics phase transitions, cancel, override) with deterministic ordering and stable serialization; UI renders newest-first event list via SimBridge snapshot | scripts/ui/FleetMenu.cs; scripts/bridge/SimBridge.cs; SimCore/Events/LogisticsEvents.cs; SimCore/Entities/Fleet.cs; SimCore.Tests/Systems/LogisticsEventStreamContractTests.cs; SimCore.Tests/Programs/FleetBindingContractTests.cs |
| GATE.UI.FLEET.DET.001 | DONE | Determinism regression for UI command interleavings: 2 fleets, scripted sequence across ticks (cancel, manual override, clear override) with save/load mid-sequence is deterministic. Regression asserts non-vacuous signature changes per step and lossless save/load, and yields identical final world signature across runs | scripts/ui/FleetMenu.cs; scripts/bridge/SimBridge.cs; SimCore/Entities/Fleet.cs; SimCore.Tests/Determinism/LogisticsMultiFleetDeterminismTests.cs; SimCore.Tests/SaveLoad/FleetManualOverrideSaveLoadContractTests.cs |
| GATE.PROG.UI.001 | DONE | Program vs ManualOverride interaction is defined and deterministic: issuing ManualOverride cancels any active LogisticsJob for that fleet and emits a schema-bound ManualOverrideSet event; ProgramSystem deterministically consumes ManualOverrideSet and pauses fleet-bound programs before intent emission; interaction is contract-tested | SimCore/Programs/ProgramSystem.cs; SimCore/Programs/ProgramBook.cs; scripts/ui/ProgramsMenu.cs; SimCore.Tests/Programs/ProgramContractTests.cs; SimCore.Tests/Programs/ProgramLifecycleContractTests.cs; SimCore/Commands/FleetSetDestinationCommand.cs; SimCore/Events/LogisticsEvents.cs; SimCore/Programs/ProgramInstance.cs |
| GATE.UI.FLEET.PLAY.001 | DONE | First playable fleet capstone is accessible and verifiable in-game: boot playable_prototype scene, dock at station, StationMenu exposes Fleets entrypoint, Fleet panel renders and supports deterministic fleet selection, CancelJob, Override, ClearOverride; ActiveController and override target are surfaced; selected fleet shows deterministic newest-first event tail with stable serialization; Save/Load mid-sequence preserves visible fleet state and event tail after refresh; headless smoke emits deterministic transcript with stable hash including Seed, tick, per-fleet state (fleet_id, command source tag, ActiveController, job fields, override target) and ordered event tail. Non-goal: no galaxy scale tuning, no procgen variety validation, no aesthetics checks, no other gameplay loops | scenes/playable_prototype.tscn + scripts/ui/StationMenu.cs + scripts/ui/FleetMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Entities/Fleet.cs + SimCore/Commands/FleetJobCancelCommand.cs + SimCore/Commands/FleetSetDestinationCommand.cs |


### B9. Slice 3 programs and logistics explainability gates (v1)
| Gate ID | Status | Gate | Evidence |
|---|---|---|---|
| GATE.UI.PROGRAMS.001 | DONE | Programs screen minimal readout via SimBridge facts only; deterministic ordering enforced (ordinal) for program list and detail fields; headless UI smoke clean; gate validation passes | scripts/ui/ProgramsMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Programs/ProgramSystem.cs + SimCore/Programs/ProgramInstance.cs |
| GATE.UI.PROGRAMS.EVENT.001 | DONE | Programs screen shows last N program events with deterministic ordering (Seq-desc, stable ties), stable serialization through save%load (quicksave v2 wraps kernel JSON + program event log), and clickable entity references (id links copy to clipboard). Note: no causal attribution yet from program events to logistics%movement event stream. | scripts/ui/ProgramsMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Programs/ProgramExplain.cs + SimCore/Programs/ProgramSystem.cs |
| GATE.UI.LOGISTICS.001 | DONE | Logistics screen minimal readout via SimBridge facts: active jobs touching current market plus bottlenecks summary from buffer deficits; nonblocking snapshot (cached when sim lock busy); deterministic ordering for displayed lists (jobs by fleet_id ordinal; bottlenecks by deficit desc, then good_id ordinal, then site_id ordinal) | scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Systems/LogisticsSystem.cs + SimCore/Entities/LogisticsJob.cs |
| GATE.UI.LOGISTICS.EVENT.001 | DONE | Station logistics panel renders deterministic incident timeline (newest first) sourced from schema-bound LogisticsEventLog; zero-pickup cancel incident expands into traversable cause chain of preceding pickup observations; stable snapshot serialization and ordering (Seq desc with tie-breakers) | scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs + SimCore/Events/LogisticsEvents.cs + SimCore/Systems/LogisticsSystem.cs |
| GATE.UI.EXPLAIN.PLAY.001 | DONE | Explainability capstone: guided headless path deterministically triggers one representative failure (credits constraint) and surfaces the full “why” chain; output is captured to docs/generated/phase3_explain_capstone_stdout.txt with stable hash64= for repro; save/load preserves explanation transcript hash (no post-load tick advance); end to end headless proof exits 0 | scripts/tests/phase3_explain_capstone.gd + scripts/bridge/SimBridge.cs + scripts/ui/StationMenu.cs + scripts/ui/ProgramsMenu.cs + SimCore/World/WorldLoader.cs + SimCore/Events/LogisticsEvents.cs + docs/generated/phase3_explain_capstone_stdout.txt |
| GATE.UI.DOCK.NONSTATION.001 | DONE | Non-station docking UI market resolution: docking at any StarNode (ex: star_16) deterministically opens StationMenu without F9; PlayerShip emits shop_toggled(true, dock_id) for both stations and non-stations by resolving id via get_sim_market_id() else sim_market_id meta else node.name; StationMenu remains usable (Undock, Fleets, Save/Load, Explain) while market panel degrades explicitly N/A when dock_id has no market mapping; no ERROR spam from market resolution on non-market nodes | scripts/player.gd + scripts/view/GalaxyView.cs + scripts/view/StarNode.cs + scripts/ui/StationMenu.cs + scripts/bridge/SimBridge.cs + scenes/playable_prototype.tscn |
